diff --git a/src/functions_framework/__init__.py b/src/functions_framework/__init__.py
index 6a0f7b7..e9107b0 100644
--- a/src/functions_framework/__init__.py
+++ b/src/functions_framework/__init__.py
@@ -23,6 +23,7 @@ import os.path
 import pathlib
 import sys
 import types
+import asyncio
 
 from typing import Any, Callable, Dict, List, Optional, Type, Union
 
@@ -57,6 +58,8 @@ _CLOUDEVENT_MIME_TYPE = "application/cloudevents+json"
 CloudEventFunction = Callable[[CloudEvent], None]
 HTTPFunction = Callable[[flask.Request], flask.typing.ResponseReturnValue]
 
+AsyncCloudEventFunction = Callable[[CloudEvent], Any]
+AsyncHTTPFunction = Callable[[Any], Any]  # Will be used with Starlette Request
 
 class _LoggingHandler(io.TextIOWrapper):
     """Logging replacement for stdout and stderr in GCF Python 3.7."""
@@ -72,7 +75,7 @@ class _LoggingHandler(io.TextIOWrapper):
         return self.stderr.write(json.dumps(payload) + "\n")
 
 
-def cloud_event(func: CloudEventFunction) -> CloudEventFunction:
+def cloud_event(func: Union[CloudEventFunction, AsyncCloudEventFunction]) -> Union[CloudEventFunction, AsyncCloudEventFunction]:
     """Decorator that registers cloudevent as user function signature type."""
     _REGISTRY_MAP[func.__name__] = (
         _FUNCTION_REGISTRY.CLOUDEVENT_SIGNATURE_TYPE
@@ -115,7 +118,7 @@ def typed(*args):
         return _typed
 
 
-def http(func: HTTPFunction) -> HTTPFunction:
+def http(func: Union[HTTPFunction, AsyncHTTPFunction]) -> Union[HTTPFunction, AsyncHTTPFunction]:
     """Decorator that registers http as user function signature type."""
     _REGISTRY_MAP[func.__name__] = (
         _FUNCTION_REGISTRY.HTTP_SIGNATURE_TYPE
@@ -707,20 +710,192 @@ def create_asgi_app(target: Optional[str] = None,
     """
     try:
         from starlette.applications import Starlette
+        from starlette.requests import Request
+        from starlette.responses import JSONResponse, Response, PlainTextResponse
+        import asyncio
         from starlette.routing import Route
+        from starlette.middleware import Middleware
     except ImportError:
         raise ImportError(
             "Starlette is required for ASGI support. "
             "Install with: pip install starlette"
         )
 
-    # Basic app with no routes yet
+    target = _function_registry.get_function_target(target)
+    source = _function_registry.get_function_source(source)
+
+    if not os.path.exists(source):
+        raise MissingSourceException(
+            f"File {source} that is expected to define function doesn't exist"
+        )
+
+    source_module, spec = _function_registry.load_function_module(source)
+
+    # Load the module and function
+    try:
+        spec.loader.exec_module(source_module)
+        function = _function_registry.get_user_function(source, source_module, target)
+    except Exception as e:
+        # When not debugging, raise the error immediately
+        raise e from None
+
+    # Get the configured function signature type
+    signature_type = _function_registry.get_func_signature_type(target, signature_type)
+    
+    # Check if the function is async
+    is_async = asyncio.iscoroutinefunction(function)
+    
+    # Setup execution context for logging
+    enable_id_logging = _enable_execution_id_logging()
+
+    # Define route handlers for each signature type
+    # Middleware to ensure entire request body is read
+    async def ensure_request_body_read(request):
+        """Ensure the request body is completely read before processing.
+        
+        This helps prevent connection errors similar to the read_request
+        function in the Flask implementation.
+        
+        Args:
+            request: The Starlette request object
+            
+        Returns:
+            The request body as bytes
+        """
+        # Force reading the entire body
+        body = await request.body()
+        return body
+    
+    @execution_id.set_asgi_execution_context(enable_id_logging)
+    async def http_handler(request):
+        # Ensure request body is fully read
+        await ensure_request_body_read(request)
+        
+        if is_async:
+            result = await function(request)
+        else:
+            # Run sync function in an executor
+            loop = asyncio.get_event_loop()
+            result = await loop.run_in_executor(None, function, request)
+        
+        # Convert result to a Starlette response
+        if isinstance(result, Response):
+            return result
+        elif isinstance(result, (dict, list)):
+            return JSONResponse(result)
+        elif isinstance(result, tuple) and len(result) == 2:
+            content, status_code = result
+            return PlainTextResponse(str(content), status_code=status_code)
+        else:
+            return PlainTextResponse(str(result) if result is not None else "")
+    
+    # Map signature types to route handlers
+    handler_map = {
+        _function_registry.HTTP_SIGNATURE_TYPE: http_handler,
+    }
+    
+    # Select the appropriate handler based on signature type
+    if signature_type not in handler_map:
+        raise FunctionsFrameworkException(f"Invalid signature type: {signature_type}")
+    
+    handler = handler_map[signature_type]
+    
+    # Define routes based on signature type
+    if signature_type == _function_registry.HTTP_SIGNATURE_TYPE:
+        routes = [
+            Route("/", handler, methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]),
+            Route("/{path:path}", handler, methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]),
+        ]
+    else:
+        # For event-based handlers, only accept POST
+        routes = [
+            Route("/", handler, methods=["POST"]),
+            Route("/{path:path}", handler, methods=["POST"]),
+        ]
+    
+    # Add the execution ID middleware
+    middleware = [
+        Middleware(execution_id.AsgiMiddleware)
+    ]
+    
+    # Create and return Starlette app with middleware
     app = Starlette(
         debug=bool(os.environ.get("DEBUG")), 
-        routes=[]
+        routes=routes,
+        middleware=middleware
     )
     
-    # We'll implement the full functionality in subsequent patches
-    
-    app.exception_handler(Exception)(lambda request, exc: None)
+    # Error handler for crash reports
+    @app.exception_handler(Exception)
+    async def exception_handler(request, exc):
+        # Log the exception for debugging
+        import traceback
+        error_message = f"Function execution failed: {str(exc)}\n"
+        error_message += traceback.format_exc()
+        import logging
+        logging.error(error_message)
+        
+        # Return a structured error response similar to the WSGI version
+        error_response = {
+            "error": str(exc),
+            "stacktrace": traceback.format_exc()
+        }
+        
+        return JSONResponse(
+            content=error_response,
+            status_code=500,
+            headers={_FUNCTION_STATUS_HEADER_FIELD: _CRASH}
+        )
     
     return app
 
