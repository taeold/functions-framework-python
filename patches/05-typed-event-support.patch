diff --git a/src/functions_framework/__init__.py b/src/functions_framework/__init__.py
index 5b04701..1c19458 100644
--- a/src/functions_framework/__init__.py
+++ b/src/functions_framework/__init__.py
@@ -749,7 +749,6 @@ def create_asgi_app(target: Optional[str] = None,
     
     # Check if the function is async
     is_async = _function_registry.is_async_func(target)
-    print(f"Function {target} is {'async' if is_async else 'sync'}")
     
     # Setup execution context for logging
     enable_id_logging = _enable_execution_id_logging()
@@ -885,9 +884,72 @@ def create_asgi_app(target: Optional[str] = None,
         except Exception as e:
             return PlainTextResponse(str(e), status_code=400)
     
+    # Define handler for typed events
+    @execution_id.set_asgi_execution_context(enable_id_logging)
+    async def typed_event_handler(request):
+        """Handle typed event requests for ASGI.
+        
+        This handler:
+        1. Parses the JSON request body
+        2. Converts it to the expected input type
+        3. Calls the function with the typed input
+        4. Converts the response back to JSON
+        """
+        try:
+            # Get the input type for this function
+            input_type = _function_registry.get_func_input_type(target)
+            if not input_type:
+                return PlainTextResponse(
+                    f"Function {target} has no registered input type",
+                    status_code=500
+                )
+            
+            # Ensure request body is fully read
+            await ensure_request_body_read(request)
+            
+            # Parse request JSON
+            try:
+                data = await request.json()
+            except Exception as e:
+                return PlainTextResponse(
+                    f"Invalid JSON payload: {str(e)}", 
+                    status_code=400
+                )
+            
+            # Convert to typed input
+            try:
+                input_obj = input_type.from_dict(data)
+            except Exception as e:
+                return PlainTextResponse(
+                    f"Failed to convert input to {input_type.__name__}: {str(e)}", 
+                    status_code=400
+                )
+            
+            # Call the function with typed input
+            if is_async:
+                response = await function(input_obj)
+            else:
+                loop = asyncio.get_event_loop()
+                response = await loop.run_in_executor(None, function, input_obj)
+            
+            # Handle the response
+            if response is None:
+                return PlainTextResponse("")
+            
+            # For primitive types
+            if response.__class__.__module__ == "builtins":
+                if isinstance(response, (str, int, float, bool)):
+                    return PlainTextResponse(str(response))
+                else:
+                    return JSONResponse(response)
+            
+            # For custom types, validate and convert to dict
+            try:
+                _typed_event._validate_return_type(response)
+                return JSONResponse(response.to_dict())
+            except Exception as e:
+                return PlainTextResponse(
+                    f"Invalid return type: {str(e)}", 
+                    status_code=500
+                )
+                
+        except Exception as e:
+            return PlainTextResponse(
+                f"Function execution failed: {str(e)}", 
+                status_code=500
+            )
+    
     # Map signature types to route handlers
     handler_map = {
         _function_registry.HTTP_SIGNATURE_TYPE: http_handler,
         _function_registry.CLOUDEVENT_SIGNATURE_TYPE: cloud_event_handler,
         _function_registry.BACKGROUNDEVENT_SIGNATURE_TYPE: event_handler,
+        _function_registry.TYPED_SIGNATURE_TYPE: typed_event_handler,
     }
     
     # Select the appropriate handler based on signature type
